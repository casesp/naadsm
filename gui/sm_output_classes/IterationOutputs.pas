unit IterationOutputs;

(*
IterationOutputs.pas
--------------------
Begin: 2005/07/28
Last revision: $Date: 2011-09-13 20:50:38 $ $Author: rhupalo $
Version number: $Revision: 1.7.4.12 $
Project: NAADSM
Website: http://www.naadsm.org
Author: Aaron Reeves <Aaron.Reeves@colostate.edu>
--------------------------------------------------
Copyright (C) 2005 - 2011 Animal Population Health Institute, Colorado State University

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General
Public License as published by the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
*)


interface

  uses
  	Contnrs,

    QOrderedDictionaries,
    QVectors,
    QIntegerMaps,

    CStringList,

    OutputDescriptions,
    SMDatabase
  ;


  {*
    To add new outputs, simply add the names, types, and descriptions in OutputDescriptions.
    For "typical" (i.e., complete, uncalculated) outputs, as long as the functions in
    OutputDescriptions are updated correctly, everything in this unit will work just fine.

    When new calculated outputs are added, update the "TIterationOutputSet.generateCalculatedXVariables()"
    functions found in this unit.

    There are some odd outputs that require special treatment for the case of "all production types".
    These must be handled by the class TProductionTypeOutputSet.  See
    "TProductionTypeOutputSet.generateVariablesForAllProductionTypes()" and related functions.

    No special handling should be required for incomplete outputs.
  }


  {*
    This class is essentially an array that contains all of the values of a single
    output generated by multiple iterations.  Functions for reporting summary
    statistics (mean, median, various percentiles, etc.) are provided.

    These arrays can be "complete" or "incomplete": "complete" means that every
    single iteration will have a value for the output of interest, and that the size
    of the array will consequently be the same as the number of iterations.  Examples
    include the total numbers of exposed, infected, and destroyed units.

    "Incomplete" means that it is possible for an iteration not to have an output.
    The output for day of first detection, for example, can be incomplete if detection
    never occurs in some outbreaks.
  }
  type TIterationOutputArray = class( TObject )
    protected
      _mean: extended;
      _median: extended;
      _stddev: extended;
      _low: extended;
      _high: extended;
      _p5: extended;
      _p25: extended;
      _p50: extended;
      _p75: extended;
      _p95: extended;

      _name: string;
      _hint: string;

      _incompleteDataset: boolean;
      _dataCount: integer;

      _values: TQDoubleVector;

      procedure initialize();

      function getMean(): extended;
      function getStddev(): extended;
      function getLow(): extended;
      function getHigh(): extended;
      function getP5(): extended;
      function getP25(): extended;
      function getP50(): extended;
      function getP75(): extended;
      function getP95(): extended;

      function getDataCount(): integer;

      procedure calculate();
      procedure removeInvalidValues( dest, src: TQDoubleVector );

    public
      constructor create( const nameStr, hintStr: string; const incompleteDataset: boolean );
      destructor destroy(); override;

      class function createCalculationNameList(): TCStringList;
      class function calculationCount(): integer;

      function calculationAtPosition( i: integer ): double;

      function asString(): string;

      procedure debug();

      property mean: extended read getMean;
      property median: extended read getP50;
      property stddev: extended read getStddev;
      property low: extended read getLow;
      property high: extended read getHigh;
      property p5: extended read getP5;
      property p25: extended read getP25;
      property p50: extended read getP50;
      property p75: extended read getP75;
      property p95: extended read getP95;

      property dataCount: integer read getDataCount;

      property name: string read _name;
      property hint: string read _hint;

      property values: TQDoubleVector read _values write _values;

      property isIncompleteDataset: boolean read _incompleteDataset;
    end
  ;

  {* A QMap
    There is one data array for each individual output.
    The integer keys of the map are members of TIterationOutputType as shown in OutputDescriptions.
    The values are instances of TIterationOutputArray.
  }
  type TIterationOutputSet = class( TQIntegerObjectMap )
    protected
      _startType, _endType: TIterationOutputType;
      _smdb: TSMDatabase;
      _zoneCostsUsed: boolean;

      procedure initialize( const statsType: TStatsType; const zoneCostsUsed: boolean );
      procedure generateCalculatedVariables( const statsType: TStatsType );
      procedure generateCalculatedCostVariables();
      procedure generateCalculatedEpiVariables();
      procedure generateCalculatedZoneVariables();
      procedure generateDurationVariables();

    public
      constructor create( db: TSMDatabase; const statsType: TStatsType; const zoneCostsUsed: boolean = false ); overload;
      constructor create(
        db: TSMDatabase;
        const statsType: TStatsType;
        const prodTypeID: integer;
        const zoneID: integer = -1;
        const zoneCostsUsed: boolean = false
      ); overload;

      destructor destroy(); override;
    
      function resultSet( const outputVariable: TIterationOutputType ): TIterationOutputArray;

      function valueAsString( arrPos, calcPos: integer ): string;

      procedure debug();
    end
   ;
  
  
  {* Another QMap
    There is one output set for each production type.
    The integer keys of the map are production type IDs, where 0 indicates all production types.
    The values are instances of TIterationOutputSet.
    
    Epi and cost outputs have this level of organization.
  }
  type TProductionTypeOutputSet = class( TQIntegerObjectMap )
    protected
      _startType, _endType: TIterationOutputType;

      procedure initialize( const statsType: TStatsType );

      procedure generateVariablesForAllProductionTypes( db: TSMDatabase; const statsType: TStatsType );
      procedure generateEpiVariablesForAllProductionTypes( db: TSMDatabase );

    public
      constructor create( const statsType: TStatsType ); overload;
      constructor create(
        db: TSMDatabase;
        const statsType: TStatsType;
        const zoneID: integer = -1;
        const zoneCostsUsed: boolean = false
      ); overload;

      destructor destroy(); override;

      class function epiOutputCount(): integer;
      class function createEpiOutputDictionary(): TQOrderedStringStringDictionary;

      class function costsOutputCount(): integer;
      class function createCostsOutputDictionary(): TQOrderedStringStringDictionary;

      function item( const prodTypeID: integer ): TIterationOutputSet;
      function resultSet( const outputVariable: TIterationOutputType; const prodTypeID: integer ): TIterationOutputArray;

      procedure debug();
    end
  ;
  
  
  {* Yet another QMap
    There is one zone/production type output set (which consists of several production type output sets) for each zone.
    The integer keys are zone IDs, where ID 0 indicates all zones.
    The values are instances of TProductionTypeOutputSet.
    
    Zone/production type (zonePT) outputs have this level of organization.
  }
  type TZonePTOutputSet = class( TQIntegerObjectMap )
    protected
      _startType, _endType: TIterationOutputType;

    public
      constructor create( db: TSMDatabase; const zoneCostsUsed: boolean );
      destructor destroy(); override;

      function item( const zoneID: integer ): TProductionTypeOutputSet;
      function resultSet( const outputVariable: TIterationOutputType; const prodTypeID, zoneID: integer ): TIterationOutputArray;

      class function zonePTOutputCount(): integer;
      class function createZonePTOutputDictionary(): TQOrderedStringStringDictionary;

      procedure debug();
    end
  ;


  {* One final QMap
    There is one zone output set for each zone.  These outputs are for zones only, and
    have nothing to do with production types.
    The integer keys are zone IDs.  There is no ID 0.
    The values are instances of TIterationOutputSet

    True zone outputs have this level of organization.
  }
  type TZoneOutputSet = class( TQIntegerObjectMap )
    protected
      _startType, _endType: TIterationOutputType;

    public
      constructor create( db: TSMDatabase );
      destructor destroy(); override;

      function item( const zoneID: integer ): TIterationOutputSet;
      function resultSet( const outputVariable: TIterationOutputType; const zoneID: integer ): TIterationOutputArray;

      class function zoneOutputCount(): integer;
      class function createZoneOutputDictionary(): TQOrderedStringStringDictionary;

      procedure debug();
    end
  ;


  {*
    A collection of all of the iteration outputs (for zones and production types)
    of all types (zones, costs, and epidemiologic outputs) generated for a scenario.
  }
  type TScenarioOutputSet = class
    protected
      _zonePTStats: TZonePTOutputSet;
      _costStats: TProductionTypeOutputSet;
      _epiStats: TProductionTypeOutputSet;
      _zoneStats: TZoneOutputSet;
    public
      constructor create( db: TSMDatabase; const costsUsed, zonesUsed, zoneCostsUsed: boolean );
      destructor destroy(); override;

      property zonePTStats: TZonePTOutputSet read _zonePTStats;
      property zoneStats: TZoneOutputSet read _zoneStats;
      property costStats: TProductionTypeOutputSet read _costStats;
      property epiStats: TProductionTypeOutputSet read _epiStats;
    end
  ;

  const
    UNSET: integer = -1;

implementation

  uses
    SysUtils,
    Math,
    Variants,
    StrUtils,
    TypInfo,

    SqlClasses,
    MyStrUtils,
    DebugWindow,
    I88n,

    ARMath
  ;


  const
  	DBSHOWMSG: boolean = false; // set to true to enable debugging messages for this unit.

//-----------------------------------------------------------------------------
// TIterationOutputArray
//-----------------------------------------------------------------------------
  constructor TIterationOutputArray.create( const nameStr, hintStr: string; const incompleteDataset: boolean );
    begin
      inherited create();

      initialize();

      _name := nameStr;
      _hint := hintStr;
      _incompleteDataset := incompleteDataset;
    end
  ;


  procedure TIterationOutputArray.initialize();
    begin
      _name := '';
      _hint := '';
      _incompleteDataset := false;

      _values := TQDoubleVector.Create();

      _mean := UNSET;
      _stddev := UNSET;
      _low := UNSET;
      _high := UNSET;
      _p5 := UNSET;
      _p25 := UNSET;
      _p50 := UNSET;
      _p75 := UNSET;
      _p95 := UNSET;

      _dataCount := UNSET;
    end
  ;


  destructor TIterationOutputArray.destroy();
    begin
      dbcout( 'Destroying array values for ' + _name + '...', DBSHOWMSG );
      _values.Free();  
      dbcout( 'Done.', DBSHOWMSG );
      inherited destroy();
    end
  ;


  class function TIterationOutputArray.createCalculationNameList(): TCStringList;
    var
      colHeaders: TCStringList;
    begin
      colHeaders := TCStringList.Create();
      with colHeaders do
        begin
          append( tr( 'Mean' ) );
          append( tr( 'StdDev' ) );
          append( tr( 'Low' ) );
          append( tr( 'High' ) );
          append( tr( 'p5' ) );
          append( tr( 'p25' ) );
          append( tr( 'p50' ) );
          append( tr( 'p75' ) );
          append( tr( 'p95' ) );
        end
      ;

      result := colHeaders;
    end
  ;


  function TIterationOutputArray.calculationAtPosition( i: integer ): double;
    begin
      case i of
        0: result := self.mean;
        1:
          begin
            if isNaN( self.stddev ) then
              result := NaN
            else
              result := self.stddev
            ;
          end
        ;
        2: result := self.low;
        3: result := self.high;
        4: result := self.p5;
        5: result := self.p25;
        6: result := self.p50;
        7: result := self.p75;
        8: result := self.p95;
        else
          raise exception.Create( 'Index out of bounds in TIterationOutputArray.calculationAtPosition()' );
      end;
    end
  ;


  class function TIterationOutputArray.calculationCount(): integer;
    begin
      result := 9;
    end
  ;


  procedure TIterationOutputArray.calculate();
    var
      tempArr: TQDoubleVector;
      i: integer;
    begin
      dbcout( 'Beginning calculation', DBSHOWMSG );

      // Don't sort values directly in the array: we'll need
      // the array just as it is to display convergence. Create
      // and sort a copy instead.
      if( not( _incompleteDataset ) ) then
        tempArr := TQDoubleVector.Create( _values )
      else
        begin
          tempArr := TQDoubleVector.Create();
          removeInvalidValues( tempArr, _values )
        end
      ;


      dbcout( 'Elements in array: ' + intToStr( tempArr.Count ), DBSHOWMSG );

      if ( 0 = tempArr.Count ) then
        begin
          _mean := NaN;
          _stddev := NaN;
          _low := NaN;
          _high := NaN;
          _p5 := NaN;
          _p25 := NaN;
          _p50 := NaN;
          _p75 := NaN;
          _p95 := NaN;
          
          tempArr.Free();
          exit;
        end
      ;
      
      if ( 1 = tempArr.Count ) then
        begin
          dbcout( 'XXXXXXXXXXXXXXX stddev will be undefined', DBSHOWMSG );
          dbcout( 'Setting mean to ' + dbFloatToStr( tempArr.at(0) ), DBSHOWMSG  );
          _mean := tempArr.at(0);
          _stddev := NaN;
        end
      else
        begin
          tempArr.Sort();
          dbcout( 'stddev should be defined', DBSHOWMSG );
          _mean := tempArr.mean();
          _stddev := tempArr.stddev();
        end
      ;

      if( DBSHOWMSG ) then
        begin
          dbcout( '*** in calculate function', DBSHOWMSG );
          for i := 0 to tempArr.Count - 1 do
            dbcout( tempArr[i], DBSHOWMSG )
          ;
        end
      ;

      dbcout( 'Setting high and low', DBSHOWMSG );
      _low := tempArr.at(0);
      _high := tempArr.at( tempArr.Count - 1 );

      dbcout( 'Getting quantiles', DBSHOWMSG );
      _p5 := tempArr.quantile( 0.05 );
      _p25 := tempArr.quantile( 0.25 );
      _p50 := tempArr.quantile( 0.50 );
      _p75 := tempArr.quantile( 0.75 );
      _p95 := tempArr.quantile( 0.95 );

      dbcout( 'Calculation was successful', DBSHOWMSG );
      tempArr.Free();
    end
  ;


  procedure TIterationOutputArray.removeInvalidValues( dest, src: TQDoubleVector );
    var
      i: integer;
      arr: TQDoubleVector;
    begin
      dbcout( '+++++++++++++++++++++++Starting removing invalid values', DBSHOWMSG );
      _dataCount := 0;
      arr := TQDoubleVector.Create();

      for i := 0 to src.Count - 1 do
        begin
          dbcout( 'Index ' + intToStr( i ) + ', value ' +  dbFloatToStr( src[i] ), DBSHOWMSG );
          if( 0 <= src[i] ) then
            begin
              arr.append( src[i] );
              inc( _dataCount );
            end
          ;
        end
      ;
      dest.Assign( arr );

      dbcout( '**************************Done removing invalid values', DBSHOWMSG );
      arr.Free();
    end
  ;


  function TIterationOutputArray.getMean(): extended;
    begin
      //dbcout( 'Getting mean for ' + self.name, DBSHOWMSG );
      //dbcout( 'mean is ' + dbFloatToStr( _mean ), DBSHOWMSG );

      if( not( isNaN( _mean ) ) ) then
        begin
          //dbcout( 'Does UNSET = _mean?', DBSHOWMSG );
          //dbcout( UNSET = _mean, DBSHOWMSG );
          
          if( UNSET = _mean ) then
            begin
              dbcout( 'Calculating for mean', DBSHOWMSG );
              calculate();
            end
          ;
        end
      ;
      //dbcout( 'Mean is ' + dbFloatToStr( _mean ), DBSHOWMSG );
      result := _mean;
      //dbcout( 'result is ' + dbFloatToStr( result ), DBSHOWMSG );
    end
  ;


  function TIterationOutputArray.getStddev(): extended;
    begin
      dbcout( 'Getting stddev for ' + self.name, DBSHOWMSG );
      if( not( isNaN( _mean ) ) ) then
        begin
          if( not( isNaN( _stddev ) ) ) then
            if( UNSET = _stddev ) then calculate()
          ;
        end
      else
        dbcout( 'Calculation is done!', DBSHOWMSG )
      ;

      if( isNaN( _stddev ) ) then
        result := NaN
      else
        result := _stddev
      ;
    end
  ;


  function TIterationOutputArray.getLow(): extended;
    begin
      if( not( isNaN( _mean ) ) ) then
        begin
          if( UNSET = _low ) then calculate();
        end
      ;
      result := _low;
    end
  ;


  function TIterationOutputArray.getHigh(): extended;
    begin
      if( not( isNaN( _mean ) ) ) then
        begin
          if( UNSET = _high ) then calculate();
        end
      ;
      result := _high;
    end
  ;


  function TIterationOutputArray.getP5(): extended;
    begin
      if( not( isNaN( _mean ) ) ) then
        begin
          if( UNSET = _p5 ) then calculate();
        end
      ;
      result := _p5;
    end
  ;


  function TIterationOutputArray.getP25(): extended;
    begin
      if( not( isNaN( _mean ) ) ) then
        begin
          if( UNSET = _p25 ) then calculate();
        end
      ;
      result := _p25;
    end
  ;


  function TIterationOutputArray.getP50(): extended;
    begin
      if( not( isNaN( _mean ) ) ) then
        begin
          if( UNSET = _p50 ) then calculate();
        end
      ;
      result := _p50;
    end
  ;


  function TIterationOutputArray.getP75(): extended;
    begin
      if( not( isNaN( _mean ) ) ) then
        begin
          if( UNSET = _p75 ) then calculate();
        end
      ;
      result := _p75;
    end
  ;


  function TIterationOutputArray.getP95(): extended;
    begin
      if( not( isNaN( _mean ) ) ) then
        begin
          if( UNSET = _p95 ) then calculate();
        end
      ;
      result := _p95;
    end
  ;

  
  function TIterationOutputArray.getDataCount(): integer;
    begin
      if( _incompleteDataset ) then
        begin
          if( UNSET = _dataCount ) then calculate();
          result := _dataCount;
        end
      else
        result := _values.Count
      ;
    end
  ;


  function TIterationOutputArray.asString(): string;
    var
      i: integer;
    begin
      result := '';

      for i := 0 to _values.Count - 1 do
        result := result + uiFloatToStr(  _values[i] ) + endl
      ;
    end
  ;


  procedure TIterationOutputArray.debug();
    var
      i: integer;
    begin
      dbcout( '---------- Begin TIterationOutputArray', true );
      dbcout( 'Items in array: ' + intToStr( _values.Count ), true );

      for i := 0 to _values.Count - 1 do
        dbcout( _values[i], true )
      ;

      dbcout( '---------- End TIterationOutputArray', true );
    end
  ;
//-----------------------------------------------------------------------------



//-----------------------------------------------------------------------------
// TIterationOutputSet
//-----------------------------------------------------------------------------
  constructor TIterationOutputSet.create( db: TSMDatabase; const statsType: TStatsType; const zoneCostsUsed: boolean = false );
    begin
      inherited create();
      initialize( statsType, zoneCostsUsed );
      _smdb := db;
    end
  ;

  
  constructor TIterationOutputSet.create( db: TSMDatabase; const statsType: TStatsType; const prodTypeID: integer; const zoneID: integer = -1; const zoneCostsUsed: boolean = false );
    var
      res: TSqlResult;
      row: TSqlRow;
      query: string;

      val: variant;

      i: TIterationOutputType;
    begin
      inherited create();
      initialize( statsType, zoneCostsUsed );

      _smdb := db;

      query := '';
      for i := _startType to _endType do
        begin
          if( not( outputDescriptionList.item(i).isCalculated ) ) then
            query := query + '`' + outputDescriptionList.item( i ).name + '`, '
          ;
        end
      ;
      
      // Strip off the extra ", "
      query := leftStr( query, length( query ) - 2 );

      case statsType of
        StatsPTZones: query := 'SELECT ' + query + ' FROM `outIterationByZoneAndProductionType`';
        StatsCosts: query := 'SELECT ' + query + ' FROM `outIterationCosts`';
        StatsEpi: query := 'SELECT ' + query + ' FROM `outIterationByProductionType`';
        StatsZones: query := 'SELECT ' + query + ' FROM `outIterationByZone`';
      end;

      if( StatsZones <> statsType ) then
        begin
          query := query + ' WHERE `productionTypeID` = ' + intToStr( prodTypeID );
          if( 0 < zoneID ) then
            query := query + ' AND `zoneID` = ' + intToStr( zoneID )
          ;
        end
      else
        begin
          if( 0 < zoneID ) then
            query := query + ' WHERE `zoneID` = ' + intToStr( zoneID )
          ;
        end
      ;

      query := query + ' ORDER BY iteration';

      res := TSqlResult.create( query, ( db as TSqlDatabase ) );

      row := res.fetchArrayFirst();
      while( nil <> row ) do
        begin
          for i := _startType to _endType do
            begin
              if( not( outputDescriptionList.item(i).isCalculated ) ) then
                begin
                  val := row.field( outputDescriptionList.item(i).name );
                  if( null = val ) then
                    begin
                      // FIX ME: Some day, the following IF statement might be useful.
                      // But we have to watch out for cost outputs or zone outputs.
                      //if( outputDescriptionList.item(i).isIncompleteDataSet ) then
                        self.resultSet( i ).values.Append( UNSET )
                      //else
                        //raise exception.Create( 'NULL database field encountered where it shouldn''t be (' + getEnumName( TypeInfo( TIterationOutputType ), ord( i ) ) + ') in TIterationOutputSet.create()' )
                      ;
                    end
                  else
                    self.resultSet( i ).values.Append( val )
                  ;
                end
              ;
            end
          ;
          row := res.fetchArrayNext();
        end
      ;

      res.free();

      generateCalculatedVariables( statsType );
    end
  ;


  procedure TIterationOutputSet.initialize( const statsType: TStatsType; const zoneCostsUsed: boolean );
    var
      results: TIterationOutputArray;
      i: TIterationOutputType;
      d: TOutputDescription;
    begin
      _zoneCostsUsed := zoneCostsUsed;
      
      case statsType of
        StatsPTZones:
          begin
            _startType := firstZonePTIterationOutput();
            _endType := lastZonePTIterationOutput();
          end
        ;
        StatsCosts:
          begin
            _startType := firstCostIterationOutput();
            _endType := lastCostIterationOutput();
          end
        ;
        StatsEpi:
          begin
            _startType := firstEpiIterationOutput();
            _endType := lastEpiIterationOutput();
          end
        ;
        StatsZones:
          begin
            _startType := firstZoneIterationOutput();
            _endType := lastZoneIterationOutput();
          end
        ;
      end;

      for i := _startType to _endType do
        begin
          d := outputDescriptionList.item( i );
          results := TIterationOutputArray.create( d.name, d.descr, d.isIncompleteDataSet );
          self.Add( integer( i ), results );
        end
      ;
    end
  ;


  destructor TIterationOutputSet.destroy();
    begin
      self.deleteValues();
      inherited destroy();
    end
  ;


  procedure TIterationOutputSet.generateDurationVariables();
    var
      dataRes: TSqlResult;
      dataRow: TSqlRow;
      db2: TSqlDatabase;
    begin
      db2 := _smdb as TSqlDatabase;

      dataRes := TSqlResult.create( db2 );

      // Create the array for outbreak duration
      dataRes.runQuery(
        'SELECT'
        + ' diseaseEnded, diseaseEndDay,'
        + ' outbreakEnded, outbreakEndDay'
        + ' FROM outIteration ORDER BY iteration'
      );

      dataRow := dataRes.fetchArrayFirst();
      while( nil <> dataRow ) do
        begin
          if( true = dataRow.field('diseaseEnded') ) then
            self.resultSet( EpiDiseaseDuration ).values.append( dataRow.field('diseaseEndDay') )
          else
            self.resultSet( EpiDiseaseDuration ).values.append( UNSET )
          ;

          if( true = dataRow.field('outbreakEnded') ) then
            self.resultSet( EpiOutbreakDuration ).values.append( dataRow.field('outbreakEndDay') )
          else
            self.resultSet( EpiOutbreakDuration ).values.append( UNSET )
          ;
          
          dataRow := dataRes.fetchArrayNext();
        end
      ;

      // Clean up
      dataRes.Free();
    end
  ;


  procedure TIterationOutputSet.generateCalculatedZoneVariables();
    var
      len: integer;
    begin
      len := self.resultSet( ZMaxZoneArea ).values.count;

      if( 0 < len ) then
        begin
          // First events
          self.resultSet( ZZonesOccurred ).values.resize( len );
          self.resultSet( ZZonesOccurred ).values.fill( self.resultSet( ZMaxZoneArea ).dataCount );
        end
      ;
    end
  ;


  procedure TIterationOutputSet.generateCalculatedEpiVariables();
    var
      len: integer;
      i: integer;
    begin
      len := self.resultSet( EpiInfcUIni ).values.count;

      if( 0 < len ) then
        begin
          // Running totals for cause of infection
          self.resultSet( EpiInfcUAll ).values.resize( len );
          self.resultSet( EpiInfcUAll ).values.fill( 0.0 );

          self.resultSet( EpiInfcAAll ).values.resize( len );
          self.resultSet( EpiInfcAAll ).values.fill( 0.0 );

          // Running totals for exposures
          self.resultSet( EpiExpcUAll ).values.resize( len );
          self.resultSet( EpiExpcUAll ).values.fill( 0.0 );

          self.resultSet( EpiExpcAAll ).values.resize( len );
          self.resultSet( EpiExpcAAll ).values.fill( 0.0 );

          // Running totals for tracing
          self.resultSet( EpiTrcUDirAll ).values.resize( len );
          self.resultSet( EpiTrcUDirAll ).values.fill( 0.0 );

          self.resultSet( EpiTrcADirAll ).values.resize( len );
          self.resultSet( EpiTrcADirAll ).values.fill( 0.0 );

          self.resultSet( EpiTrcUIndAll ).values.resize( len );
          self.resultSet( EpiTrcUIndAll ).values.fill( 0.0 );

          self.resultSet( EpiTrcAIndAll ).values.resize( len );
          self.resultSet( EpiTrcAIndAll ).values.fill( 0.0 );

          self.resultSet( EpiTrcUAll ).values.resize( len );
          self.resultSet( EpiTrcUAll ).values.fill( 0.0 );

          self.resultSet( EpiTrcAAll ).values.resize( len );
          self.resultSet( EpiTrcAAll ).values.fill( 0.0 );

          // Running totals for trace origins
          self.resultSet( EpiTocUDirAll ).values.resize( len );
          self.resultSet( EpiTocUDirAll ).values.fill( 0.0 );

          self.resultSet( EpiTocUIndAll ).values.resize( len );
          self.resultSet( EpiTocUIndAll ).values.fill( 0.0 );

          self.resultSet( EpiTocUAll ).values.resize( len );
          self.resultSet( EpiTocUAll ).values.fill( 0.0 );

          // Running totals for detection
          self.resultSet( EpiDetcUAll ).values.resize( len );
          self.resultSet( EpiDetcUAll ).values.fill( 0.0 );

          self.resultSet( EpiDetcAAll ).values.resize( len );
          self.resultSet( EpiDetcAAll ).values.fill( 0.0 );

          // Running totals for exams
          self.resultSet( EpiExmcUDirAll ).values.resize( len );
          self.resultSet( EpiExmcUDirAll ).values.fill( 0.0 );

          self.resultSet( EpiExmcADirAll ).values.resize( len );
          self.resultSet( EpiExmcADirAll ).values.fill( 0.0 );

          self.resultSet( EpiExmcUIndAll ).values.resize( len );
          self.resultSet( EpiExmcUIndAll ).values.fill( 0.0 );

          self.resultSet( EpiExmcAIndAll ).values.resize( len );
          self.resultSet( EpiExmcAIndAll ).values.fill( 0.0 );

          self.resultSet( EpiExmcUAll ).values.resize( len );
          self.resultSet( EpiExmcUAll ).values.fill( 0.0 );

          self.resultSet( EpiExmcAAll ).values.resize( len );
          self.resultSet( EpiExmcAAll ).values.fill( 0.0 );

          // Running totals for diagnostic testing
          self.resultSet( EpiTstcUDirAll ).values.resize( len );
          self.resultSet( EpiTstcUDirAll ).values.fill( 0.0 );

          self.resultSet( EpiTstcADirAll ).values.resize( len );
          self.resultSet( EpiTstcADirAll ).values.fill( 0.0 );

          self.resultSet( EpiTstcUIndAll ).values.resize( len );
          self.resultSet( EpiTstcUIndAll ).values.fill( 0.0 );

          self.resultSet( EpiTstcAIndAll ).values.resize( len );
          self.resultSet( EpiTstcAIndAll ).values.fill( 0.0 );

          self.resultSet( EpiTstcUAll ).values.resize( len );
          self.resultSet( EpiTstcUAll ).values.fill( 0.0 );

          self.resultSet( EpiTstcAAll ).values.resize( len );
          self.resultSet( EpiTstcAAll ).values.fill( 0.0 );

          // Running totals for vaccination
          self.resultSet( EpiVaccUAll ).values.resize( len );
          self.resultSet( EpiVaccUAll ).values.fill( 0.0 );

          self.resultSet( EpiVaccAAll ).values.resize( len );
          self.resultSet( EpiVaccAAll ).values.fill( 0.0 );

          // Running totals for destruction
          self.resultSet( EpiDescUAll ).values.resize( len );
          self.resultSet( EpiDescUAll ).values.fill( 0.0 );

          self.resultSet( EpiDescAAll ).values.resize( len );
          self.resultSet( EpiDescAAll ).values.fill( 0.0 );

          // First events
          self.resultSet( EpiDetOccurred ).values.resize( len );
          self.resultSet( EpiDetOccurred ).values.fill( self.resultSet( EpiFirstDetection ).dataCount );
          self.resultSet( EpiVaccOccurred ).values.resize( len );
          self.resultSet( EpiVaccOccurred ).values.fill( self.resultSet( EpiFirstVaccination ).dataCount );
          self.resultSet( EpiDestrOccurred ).values.resize( len );
          self.resultSet( EpiDestrOccurred ).values.fill( self.resultSet( EpiFirstDestruction ).dataCount );

          // Outbreak duration
          self.resultSet( EpiDiseaseEnded ).values.resize( len );
          self.resultSet( EpiDiseaseEnded ).values.fill( self.resultSet( EpiDiseaseDuration ).dataCount );
          self.resultSet( EpiOutbreakEnded ).values.resize( len );
          self.resultSet( EpiOutbreakEnded ).values.fill( self.resultSet( EpiOutbreakDuration ).dataCount );

          for i := 0 to len - 1 do
            begin
              // Running totals for cause of infection
              // DO NOT include initially infected units/animals
              self.resultSet( EpiInfcUAll ).values[i] :=
                self.resultSet( EpiInfcUAir ).values[i]
                + self.resultSet( EpiInfcUDir ).values[i]
                + self.resultSet( EpiInfcUInd ).values[i]
              ;

              self.resultSet( EpiInfcAAll ).values[i] :=
                self.resultSet( EpiInfcAAir ).values[i]
                + self.resultSet( EpiInfcADir ).values[i]
                + self.resultSet( EpiInfcAInd ).values[i]
              ;

              // Running totals for exposures
              self.resultSet( EpiExpcUAll ).values[i] :=
                 self.resultSet( EpiExpcUDir ).values[i]
                + self.resultSet( EpiExpcUInd ).values[i]
              ;

              self.resultSet( EpiExpcAAll ).values[i] :=
                 self.resultSet( EpiExpcADir ).values[i]
                + self.resultSet( EpiExpcAInd ).values[i]
              ;

              // Running totals for tracing
              self.resultSet( EpiTrcUDirAll ).values[i] :=
                self.resultSet( EpiTrcUDirFwd ).values[i]
                + self.resultSet( EpiTrcUDirBack ).values[i]
              ;

              self.resultSet( EpiTrcADirAll ).values[i] :=
                self.resultSet( EpiTrcADirFwd ).values[i]
                + self.resultSet( EpiTrcADirBack ).values[i]
              ;

              self.resultSet( EpiTrcUIndAll ).values[i] :=
                self.resultSet( EpiTrcUIndFwd ).values[i]
                + self.resultSet( EpiTrcUIndBack ).values[i]
              ;

              self.resultSet( EpiTrcAIndAll ).values[i] :=
                self.resultSet( EpiTrcAIndFwd ).values[i]
                + self.resultSet( EpiTrcAIndBack ).values[i]
              ;

              self.resultSet( EpiTrcUAll ).values[i] :=
                self.resultSet( EpiTrcUDirAll ).values[i]
                + self.resultSet( EpiTrcUIndAll ).values[i]
              ;

              self.resultSet( EpiTrcAAll ).values[i] :=
                self.resultSet( EpiTrcADirAll ).values[i]
                + self.resultSet( EpiTrcAIndAll ).values[i]
              ;

              // Running totals for trace origins
              self.resultSet( EpiTocUDirAll ).values[i] :=
                self.resultSet( EpiTocUDirFwd ).values[i]
                + self.resultSet( EpiTocUDirBack ).values[i]
              ;

              self.resultSet( EpiTocUIndAll ).values[i] :=
                self.resultSet( EpiTocUIndFwd ).values[i]
                + self.resultSet( EpiTocUIndBack ).values[i]
              ;

              self.resultSet( EpiTocUAll ).values[i] :=
                self.resultSet( EpiTocUDirAll ).values[i]
                + self.resultSet( EpiTocUIndAll ).values[i]
              ;

              // Running totals for detection
              self.resultSet( EpiDetcUAll ).values[i] :=
                self.resultSet( EpiDetcUClin ).values[i]
                + self.resultSet( EpiDetcUTest ).values[i]
              ;

              self.resultSet( EpiDetcAAll ).values[i] :=
                self.resultSet( EpiDetcAClin ).values[i]
                + self.resultSet( EpiDetcATest ).values[i]
              ;

              // Running totals for exams
              self.resultSet( EpiExmcUDirAll ).values[i] :=
                self.resultSet( EpiExmcUDirFwd ).values[i]
                + self.resultSet( EpiExmcUDirBack ).values[i]
              ;

              self.resultSet( EpiExmcADirAll ).values[i] :=
                self.resultSet( EpiExmcADirFwd ).values[i]
                + self.resultSet( EpiExmcADirBack ).values[i]
              ;

              self.resultSet( EpiExmcUIndAll ).values[i] :=
                self.resultSet( EpiExmcUIndFwd ).values[i]
                + self.resultSet( EpiExmcUIndBack ).values[i]
              ;

              self.resultSet( EpiExmcAIndAll ).values[i] :=
                self.resultSet( EpiExmcAIndFwd ).values[i]
                + self.resultSet( EpiExmcAIndBack ).values[i]
              ;

              self.resultSet( EpiExmcUAll ).values[i] :=
                self.resultSet( EpiExmcUDirAll ).values[i]
                + self.resultSet( EpiExmcUIndAll ).values[i]
              ;

              self.resultSet( EpiExmcAAll ).values[i] :=
                self.resultSet( EpiExmcADirAll ).values[i]
                + self.resultSet( EpiExmcAIndAll ).values[i]
              ;

              // Running totals for diagnostic testing
              self.resultSet( EpiTstcUDirAll ).values[i] :=
                self.resultSet( EpiTstcUDirFwd ).values[i]
                + self.resultSet( EpiTstcUDirBack ).values[i]
              ;

              self.resultSet( EpiTstcADirAll ).values[i] :=
                self.resultSet( EpiTstcADirFwd ).values[i]
                + self.resultSet( EpiTstcADirBack ).values[i]
              ;

              self.resultSet( EpiTstcUIndAll ).values[i] :=
                self.resultSet( EpiTstcUIndFwd ).values[i]
                + self.resultSet( EpiTstcUIndBack ).values[i]
              ;

              self.resultSet( EpiTstcAIndAll ).values[i] :=
                self.resultSet( EpiTstcAIndFwd ).values[i]
                + self.resultSet( EpiTstcAIndBack ).values[i]
              ;

              self.resultSet( EpiTstcUAll ).values[i] :=
                self.resultSet( EpiTstcUDirAll ).values[i]
                + self.resultSet( EpiTstcUIndAll ).values[i]
              ;

              self.resultSet( EpiTstcAAll ).values[i] :=
                self.resultSet( EpiTstcADirAll ).values[i]
                + self.resultSet( EpiTstcAIndAll ).values[i]
              ;

              // Running totals for vaccination
              // DO NOT include initially vaccinated units/animals
              self.resultSet( EpiVaccUAll ).values[i] :=
                 self.resultSet( EpiVaccURing ).values[i]
              ;

              self.resultSet( EpiVaccAAll ).values[i] :=
                 self.resultSet( EpiVaccARing ).values[i]
              ;

              // Running totals for destruction
              // DO NOT include initially destroyed units/animals
              self.resultSet( EpiDescUAll ).values[i] :=
                self.resultSet( EpiDescUDet ).values[i]
                + self.resultSet( EpiDescUDirFwd ).values[i]
                + self.resultSet( EpiDescUIndFwd ).values[i]
                + self.resultSet( EpiDescUDirBack ).values[i]
                + self.resultSet( EpiDescUIndBack ).values[i]
                + self.resultSet( EpiDescURing ).values[i]
              ;

              self.resultSet( EpiDescAAll ).values[i] :=
                self.resultSet( EpiDescADet ).values[i]
                + self.resultSet( EpiDescADirFwd ).values[i]
                + self.resultSet( EpiDescAIndFwd ).values[i]
                + self.resultSet( EpiDescADirBack ).values[i]
                + self.resultSet( EpiDescAIndBack ).values[i]
                + self.resultSet( EpiDescARing ).values[i]
              ;
            end
          ;
        end
      ;
    end
  ;


  procedure TIterationOutputSet.generateCalculatedCostVariables();
    var
      destrLen, vaccLen, len: integer;
      i: integer;
      vSetup, vVaccination: currency;
      dAppraisal, dCleaning, dEuthanasia, dIndemnification, dDisposal: currency;
    begin
      len := 0;

      vaccLen := self.resultSet( CVaccSetup ).values.count;
      if( 0 < vaccLen ) then
        begin
          len := vaccLen;

          self.resultSet( CVaccSubtotal ).values.resize( vaccLen );
          self.resultSet( CVaccSubtotal ).values.fill( 0.0 );

          for i := 0 to vaccLen - 1 do
            begin
              //rbh Issue 2491. When only modeling destr then vacc params can be undefined (but initialized to -1).
              // There may be a better fix, but this does correct the totalCosts calculation.

              vSetup := self.resultSet( CVaccSetup ).values[i];
              if (0 > vSetup) then vSetup := 0;

              vVaccination := self.resultSet( CVaccVaccination ).values[i];
              if (0 > vVaccination) then vVaccination := 0;

              self.resultSet( CVaccSubtotal ).values[i] := vSetup + vVaccination;

              {self.resultSet( CVaccSubtotal ).values[i] :=
                self.resultSet( CVaccSetup ).values[i]
                + self.resultSet( CVaccVaccination ).values[i]
              ;}
            end
          ;
        end
      ;

      destrLen := self.resultSet( CDestrAppraisal ).values.count;
      if( 0 < destrLen ) then
        begin
          len := destrLen;

          self.resultSet( CDestrSubtotal ).values.resize( destrLen );
          self.resultSet( CDestrSubtotal ).values.fill( 0.0 );

          for i := 0 to destrLen - 1 do
            begin
               //rbh Issue 2491. When only modeling vacc then destr params can be undefined (but initialized to -1).
              // There may be a better fix, but this does correct the totalCosts calculation.

              dAppraisal := self.resultSet( CDestrAppraisal ).values[i];
              if (0 > dAppraisal) then dAppraisal := 0;

              dCleaning := self.resultSet( CDestrCleaning ).values[i];
              if (0 > dCleaning) then dCleaning := 0;

              dEuthanasia := self.resultSet( CDestrEuthanasia ).values[i];
              if (0 > dEuthanasia) then dEuthanasia := 0;

              dIndemnification := self.resultSet( CDestrIndemnification ).values[i];
              if (0 > dIndemnification) then dIndemnification := 0;

              dDisposal := self.resultSet( CDestrDisposal ).values[i];
              if (0 > dDisposal) then dDisposal := 0;

              self.resultSet( CDestrSubtotal ).values[i] :=
                dAppraisal + dCleaning + dEuthanasia + dIndemnification + dDisposal
              ;

              {self.resultSet( CDestrSubtotal ).values[i] :=
                self.resultSet( CDestrAppraisal ).values[i]
                + self.resultSet( CDestrCleaning ).values[i]
                + self.resultSet( CDestrEuthanasia ).values[i]
                + self.resultSet( CDestrIndemnification ).values[i]
                + self.resultSet( CDestrDisposal ).values[i]
              ;}
            end
          ;
        end
      ;

      if(  0 < len ) then
        begin
          self.resultSet( CCostsTotal ).values.resize( len );
          self.resultSet( CCostsTotal ).values.fill( 0.0 );

          for i := 0 to len - 1 do
            begin
              if( 0 < vaccLen ) then
                self.resultSet( CCostsTotal ).values[i] := self.resultSet( CCostsTotal ).values[i] + self.resultSet( CVaccSubtotal ).values[i]
              ;
              if( 0 < destrLen ) then
                self.resultSet( CCostsTotal ).values[i] := self.resultSet( CCostsTotal ).values[i] + self.resultSet( CDestrSubtotal ).values[i]
              ;
            end
          ;
        end
      ;
    end
  ;


  procedure TIterationOutputSet.generateCalculatedVariables( const statsType: TStatsType );
    begin
      case statsType of
        StatsZones: generateCalculatedZoneVariables();
        StatsPTZones: { Do nothing: there are no calculated variables. };
        StatsCosts: generateCalculatedCostVariables();
        StatsEpi:
          begin
            generateDurationVariables();
            generateCalculatedEpiVariables();
          end
        ;
      end;
    end
  ;


  function TIterationOutputSet.resultSet( const outputVariable: TIterationOutputType ): TIterationOutputArray;
    begin
      result := value( integer( outputVariable ) ) as TIterationOutputArray;
    end
  ;


  function TIterationOutputSet.valueAsString( arrPos, calcPos: integer ): string;
    var
      d: double;
      rs: TIterationOutputArray;
      v: TIterationOutputType;
    begin
      v := TIterationOutputType( arrPos );
      rs := resultSet( v );

      if( nil <> rs ) then
        begin
          d := rs.calculationAtPosition( calcPos );
          if( isNaN( d ) ) then
            result := tr( 'n/a' )
          else
            begin
              if( v in costIterationOutputTypes() ) then
                result := uiFloatToStrZeroPadded( d, 2 )
              else if( v in zonePTCostIterationOutputTypes() ) then
                begin
                  if( _zoneCostsUsed ) then
                    result := uiFloatToStrZeroPadded( d, 2 )
                  else
                    result := tr( 'n/a' )
                  ;
                end
              else
                result := uiFloatToStr( d, 2 )
              ;
            end
          ;

          if
            ( ZZonesOccurred = v )
          or
            ( v in [ EpiDetOccurred, EpiVaccOccurred, EpiDestrOccurred, EpiDiseaseEnded, EpiOutbreakEnded ] )
          then
            begin
              if( 0 = calcPos ) then
                begin
                  if( not( isNaN( d ) ) ) then
                    result := intToStr( trunc( d ) ) + ' ' +  tr( 'of' ) + ' ' + intToStr( _smdb.completedIterations ) + ' ' + tr( 'iterations' )
                  ;
                end
              else
                result := ''
              ;
            end
          ;

        end
      else
        result := tr( 'n/a' )
      ;
    end
  ;


  procedure TIterationOutputSet.debug();
    var
      it: TQIntegerObjectMapIterator;
      rs: TIterationOutputArray;
    begin
      it := TQIntegerObjectMapIterator.create( self );

      repeat
        if( nil <> it.value() ) then
          begin
            rs := it.value() as TIterationOutputArray;

            dbcout( endl + 'TIterationOutputSet debug: index ' + intToStr( it.key() ), true );
            rs.debug();
            dbcout( 'Done TIterationOutputSet debug' + endl, true );

            it.incr();
          end
        ;
      until ( nil = it.value() );

      it.Free();
    end
  ;
//-----------------------------------------------------------------------------



//-----------------------------------------------------------------------------
// TProductionTypeOutputSet
//-----------------------------------------------------------------------------
  constructor TProductionTypeOutputSet.create( const statsType: TStatsType );
    begin
      inherited create();
      initialize( statsType );
    end
  ;


  constructor TProductionTypeOutputSet.create(
        db: TSMDatabase;
        const statsType: TStatsType;
        const zoneID: integer = -1;
        const zoneCostsUsed: boolean = false
      );
    var
      olSet: TIterationOutputSet;
      res: TSqlResult;
      row: TSqlRow;
      query: string;

      prodTypeID: integer;

      it: TQIntegerObjectMapIterator;
      ol: TIterationOutputSet;
      j: integer;

      k: TIterationOutputType;
    begin
      inherited create();
      initialize( statsType );

      query := 'SELECT `productionTypeID` FROM `inProductionType`';

      res := TSqlResult.create( query, ( db as TSqlDatabase ) );

      row := res.fetchArrayFirst();
      while( nil <> row ) do
        begin
          // For each production type ID and zone ID (if assigned), create an instance of TIterationOutputSet
          // and add it to this map.
          prodTypeID := row.field('productionTypeID');

          olSet := TIterationOutputSet.create( db, statsType, prodTypeID, zoneID, zoneCostsUsed );
          self.Add( prodTypeID, olSet );

          row := res.fetchArrayNext();
        end
      ;
      res.free();

      // Create the special case for production type ID 0
      olSet := TIterationOutputSet.create( db, statsType, zoneCostsUsed );

      it := TQIntegerObjectMapIterator.create( self );

      if( nil <> it.value() ) then
        begin
          repeat
            ol := (it.value() as TIterationOutputSet);

            for k := _startType to _endType do
              begin
                if
                  ( 0 = olSet.resultSet( k ).values.count )
                and
                  ( 0 < ol.resultSet( k ).values.count )
                then
                  begin
                    olSet.resultSet( k ).values.resize( ol.resultSet( k ).values.count );

                    if( k in
                        [
                          EpiFirstDetection, EpiFirstDestruction, EpiFirstVaccination, EpiLastDetection,
                          EpiDiseaseDuration, EpiOutbreakDuration,
                          EpiDeswUMax, EpiDeswAMax, EpiDeswUMaxDay, EpiDeswAMaxDay, EpiDeswUTimeMax, epiDeswUTimeAvg,
                          EpiVacwUMax, EpiVacwAMax, EpiVacwUMaxDay, EpiVacwAMaxDay, EpiVacwUTimeMax, epiVacwUTimeAvg
                        ]
                    ) then
                      olSet.resultSet( k ).values.Fill( UNSET )
                    else
                      olSet.resultSet( k ).values.Fill( 0.0 )
                    ;
                  end
                ;

                // For first events, take the minimum value for any production type
                if( k in [ EpiFirstDetection, EpiFirstDestruction, EpiFirstVaccination ] ) then
                  begin
                    for j := 0 to ol.resultSet( k ).values.count - 1 do
                      begin
                        if
                          ( UNSET <> ol.resultSet( k ).values[j] )
                        and
                          (
                            ( ol.resultSet( k ).values[j] < olSet.resultSet( k ).values[j] )
                          or
                            ( UNSET = olSet.resultSet( k ).values[j] )
                          )
                        then
                          olSet.resultSet( k ).values[j] := ol.resultSet( k ).values[j]
                        ;
                      end
                    ;
                  end
                // For last events, take the maximum value for any production type
                else if( k in [ EpiLastDetection ] ) then
                  begin
                    for j := 0 to ol.resultSet( k ).values.count - 1 do
                      begin
                        if
                          ( UNSET <> ol.resultSet( k ).values[j] )
                        and
                          (
                            ( ol.resultSet( k ).values[j] > olSet.resultSet( k ).values[j] )
                          or
                            ( UNSET = olSet.resultSet( k ).values[j] )
                          )
                        then
                          olSet.resultSet( k ).values[j] := ol.resultSet( k ).values[j]
                        ;
                      end
                    ;
                  end
                // For the following outputs, don't sum them:
                // just copy them from the production type that has the highest number of events.
                else if( k in
                  [
                    EpiDetOccurred, EpiVaccOccurred, EpiDestrOccurred,
                    EpiDiseaseDuration, EpiOutbreakDuration,
                    EpiDiseaseEnded, EpiOutbreakEnded
                  ]
                ) then
                  begin
                    for j := 0 to ol.resultSet( k ).values.count - 1 do
                      begin
                        if( ol.resultSet( k ).values[j] > olSet.resultSet( k ).values[j] ) then
                          olSet.resultSet( k ).values[j] := ol.resultSet( k ).values[j]
                        ;
                      end
                    ;
                  end
                else if( k in
                  [
                    EpiDeswUMax, EpiDeswAMax, EpiDeswUMaxDay, EpiDeswAMaxDay, EpiDeswUTimeMax, epiDeswUTimeAvg,
                    EpiVacwUMax, EpiVacwAMax, EpiVacwUMaxDay, EpiVacwAMaxDay, EpiVacwUTimeMax, epiVacwUTimeAvg
                  ]
                ) then
                  begin
                    // Don't do anything with these variables:
                    // they will be taken care of in generateVariablesForAllProductionTypes().
                  end
                else
                  begin
                    // For ordinary outputs, just sum the individual production type values
                    // to get the value for "all production types".
                    for j := 0 to ol.resultSet( k ).values.count - 1 do
                      olSet.resultSet( k ).values[j] := olSet.resultSet( k ).values[j] + ol.resultSet( k ).values[j]
                    ;
                  end
                ;
              end
            ;

            it.incr();
          until ( nil = it.value() );

        end
      ;

      it.Free();

      self.Add( 0, olSet );

      generateVariablesForAllProductionTypes( db, statsType );
    end
  ;


  procedure TProductionTypeOutputSet.initialize( const statsType: TStatsType );
    begin
      case  statsType of
        StatsZones:
          begin
            _startType := firstZoneIterationOutput();
            _endType := lastZoneIterationOutput();
          end
        ;
        StatsPTZones:
          begin
            _startType := firstZonePTIterationOutput();
            _endType := lastZonePTIterationOutput();
          end
        ;
        StatsCosts:
          begin
            _startType := firstCostIterationOutput();
            _endType := lastCostIterationOutput();
          end
        ;
        StatsEpi:
          begin
            _startType := firstEpiIterationOutput();
            _endType := lastEpiIterationOutput();
          end
        ;
      end;
    end
  ;


  destructor TProductionTypeOutputSet.destroy();
    begin
      self.deleteValues();
      inherited destroy();
    end
  ;


  function TProductionTypeOutputSet.item( const prodTypeID: integer ): TIterationOutputSet;
    begin
      result := value( prodTypeID ) as TIterationOutputSet;
    end
  ;


  function TProductionTypeOutputSet.resultSet( const outputVariable: TIterationOutputType; const prodTypeID: integer ): TIterationOutputArray;
    begin
      result := self.item( prodTypeID ).resultSet( outputVariable );
    end
  ;


  procedure TProductionTypeOutputSet.generateVariablesForAllProductionTypes( db: TSMDatabase; const statsType: TStatsType );
    begin
      case statsType of
        StatsEpi: generateEpiVariablesForAllProductionTypes( db );
        StatsCosts: { Do nothing };
        StatsPTZones: { Do nothing };
        StatsZones: { Do nothing };
      end;
    end
  ;


  procedure TProductionTypeOutputSet.generateEpiVariablesForAllProductionTypes( db: TSMDatabase );
    var
      i: integer;
      outputSet: TIterationOutputSet;

      q: string;
      res: TSqlResult;
      row: TSqlRow;
    begin
      // Retrieve variables that require special handling directly from the database
      //----------------------------------------------------------------------------
      q := ''
        + ' SELECT'

        + '   `deswUMax`,'
        + '   `deswAMax`,'

        + '   `deswUMaxDay`,'
        + '   `deswAMaxDay`,'
        + '   `deswUTimeMax`,'
        + '   `deswUTimeAvg`,'

        + '   `vacwUMax`,'
        + '   `vacwAMax`,'
        + '   `vacwUMaxDay`,'
        + '   `vacwAMaxDay`,'
        + '   `vacwUTimeMax`,'
        + '   `vacwUTimeAvg`'

        + ' FROM `outIteration`'
        + ' ORDER BY `iteration`'
      ;

      dbcout2( q );

      res := TSqlResult.create( q, ( db as TSqlDatabase ) );

      dbcout2( res.numRows );

      row := res.fetchArrayFirst();

      outputSet := self.item( 0 );
      i := 0;
      while( nil <> row ) do
        begin
          outputSet.resultSet( EpiDeswUMax ).values[i] := row.field( 'deswUMax' );
          outputSet.resultSet( EpiDeswAMax ).values[i] := integer( row.field( 'deswAMax' )) ;

          outputSet.resultSet( EpiDeswUMaxDay ).values[i] := row.field( 'deswUMaxDay' );
          outputSet.resultSet( EpiDeswAMaxDay ).values[i] := row.field( 'deswAMaxDay' );
          outputSet.resultSet( EpiDeswUTimeMax ).values[i] := row.field( 'deswUTimeMax' );
          outputSet.resultSet( EpiDeswUTimeAvg ).values[i] := row.field( 'deswUTimeAvg' );

          outputSet.resultSet( EpiVacwUMax ).values[i] := row.field( 'vacwUMax' );
          outputSet.resultSet( EpiVacwAMax ).values[i] := row.field( 'vacwAMax' );
          outputSet.resultSet( EpiVacwUMaxDay ).values[i] := row.field( 'vacwUMaxDay' );
          outputSet.resultSet( EpiVacwAMaxDay ).values[i] := row.field( 'vacwAMaxDay' );
          outputSet.resultSet( EpiVacwUTimeMax ).values[i] := row.field( 'vacwUTimeMax' );
          outputSet.resultSet( EpiVacwUTimeAvg ).values[i] := row.field( 'vacwUTimeAvg' );

          inc( i );
          row := res.fetchArrayNext();
        end
      ;

      res.Free();
    end
  ;


  class function TProductionTypeOutputSet.costsOutputCount(): integer;
    var
      i: integer;
    begin
      result := 0;
      for i := integer( firstCostIterationOutput() ) to integer( lastCostIterationOutput() ) do
        inc( result )
      ;
    end
  ;


  class function TProductionTypeOutputSet.createCostsOutputDictionary(): TQOrderedStringStringDictionary;
    begin
      result := createOutputDictionary( firstCostIterationOutput(), lastCostIterationOutput() );
    end
  ;


  class function TProductionTypeOutputSet.epiOutputCount(): integer;
    var
      i: integer;
    begin
      result := 0;
      for i := integer( firstEpiIterationOutput() ) to integer( lastEpiIterationOutput() ) do
        inc( result )
      ;
    end
  ;


  class function TProductionTypeOutputSet.createEpiOutputDictionary(): TQOrderedStringStringDictionary;
    begin
      result := createOutputDictionary( firstEpiIterationOutput(), lastEpiIterationOutput() );
    end
  ;


  procedure TProductionTypeOutputSet.debug();
    var
      it: TQIntegerObjectMapIterator;
      ol: TIterationOutputSet;
    begin
      it := TQIntegerObjectMapIterator.create( self );

      repeat
        if( nil <> it.value() ) then
          begin
            ol := it.value() as TIterationOutputSet;

            dbcout( endl + 'TProductionTypeOutputSet debug: index ' + intToStr( it.key() ), true );
            ol.debug();
            dbcout( 'Done TProductionTypeOutputSet debug' + endl, true );

            it.incr();
          end
        ;
      until ( nil = it.value() );

      it.Free();
    end
  ;
//-----------------------------------------------------------------------------



//-----------------------------------------------------------------------------
// TZonePTOutputSet
//-----------------------------------------------------------------------------
  constructor TZonePTOutputSet.create( db: TSMDatabase; const zoneCostsUsed: boolean );
    var
      ptlSet: TProductionTypeOutputSet;

      res: TSqlResult;
      row: TSqlRow;
      query: string;

      zoneID: integer;
      zoneIDVector: TQIntegerVector;

      ptIDVector: TQIntegerVector;
      pit: TQIntegerObjectMapIterator;
      pl: TProductionTypeOutputSet;

      olSet: TIterationOutputSet;
      oit: TQIntegerObjectMapIterator;
      ol: TIterationOutputSet;

      i, j, k: integer;

      m: TIterationOutputType;
    begin
      inherited create();

      _startType := firstZonePTIterationOutput();
      _endType := lastZonePTIterationOutput();

      zoneIDVector := TQIntegerVector.create();

      query := 'SELECT `zoneID` FROM `inZone`';

      res := TSqlResult.create( query, ( db as TSqlDatabase ) );

      row := res.fetchArrayFirst();
      while( nil <> row ) do
        begin
          // For each zone ID, create an instance of TProductionTypeOutputSet
          // and add it to this map.
          zoneID := row.field('zoneID');
          zoneIDVector.append( zoneID );

          ptlSet := TProductionTypeOutputSet.create( db, StatsPTZones, zoneID, zoneCostsUsed );
          self.Add( zoneID, ptlSet );

          row := res.fetchArrayNext();
        end
      ;

      res.Free();

      // Create the special case for zone ID 0
      //--------------------------------------
      // Create a new pt-level output set for zone ID 0
      // Build an integer array that contains all production type keys
      // For each pt key, select the corresponding item in each pt-level output set
      // Sum these up to create a new result set, and add it to the new pt-level output set

      ptlSet := TProductionTypeOutputSet.create( StatsPTZones );

      ptIDVector := TQIntegerVector.create();

      pit := TQIntegerObjectMapIterator.create( self );
      if( nil <> pit.value() ) then
        begin
          pl := pit.value() as TProductionTypeOutputSet;

          oit := TQIntegerObjectMapIterator.create( pl );
          if( nil <> oit.value() ) then
            begin
              repeat
                ptIDVector.append( oit.key );
                oit.incr();
              until nil = oit.value();
            end
          ;
          oit.Free();
        end
      ;
      pit.Free();

      if( 0 < ptIDVector.count ) then
        begin
          for i := 0 to ptIDVector.count - 1 do
            begin
              // First, just set the sizes for the double arrays
              ol := self.item( zoneIDVector[0] ).item( ptIDVector[0] );
              olSet := TIterationOutputSet.create( nil, StatsPTZones, zoneCostsUsed );

              for m := _startType to _endType do
                begin
                  olSet.resultSet( m ).values.resize( ol.resultSet( m ).values.count );
                  olSet.resultSet( m ).values.Fill( 0.0 );
                end
              ;

              // Then sum up the values...
              for j := 0 to zoneIDVector.count - 1 do
                begin
                  ol := self.item( zoneIDVector[j] ).item( ptIDVector[i] );

                  for m := _startType to _endType do
                    begin
                      for k := 0 to ol.resultSet( m ).values.count - 1 do
                        olSet.resultSet( m ).values[k] := olSet.resultSet( m ).values[k] + ol.resultSet( m ).values[k]
                      ;
                    end
                  ;
                end
              ;

              // ... and insert the new output-level result set (with summed values) into the new production type-level result set
              ptlSet.insert( ptIDVector[i], olSet );
            end
          ;
        end
      ;

      ptIDVector.Free();
      zoneIDVector.Free();

      // Finally, insert the new production-type level result set into this list, with the special zone ID of 0
      self.insert( 0, ptlSet );
    end
  ;


  destructor TZonePTOutputSet.destroy();
    begin
      self.deleteValues();
      inherited destroy();
    end
  ;


  function TZonePTOutputSet.item( const zoneID: integer ): TProductionTypeOutputSet;
    begin
      result := value( zoneID ) as TProductionTypeOutputSet;
    end
  ;

  
  function TZonePTOutputSet.resultSet( const outputVariable: TIterationOutputType; const prodTypeID, zoneID: integer ): TIterationOutputArray;
    begin
      result := self.item( zoneID ).item( prodTypeID ).resultSet( outputVariable );
    end
  ;


  class function TZonePTOutputSet.zonePTOutputCount(): integer;
    var
      i: integer;
    begin
      result := 0;
      for i := integer( firstZonePTIterationOutput() ) to integer( lastZonePTIterationOutput() ) do
        inc( result )
      ;
    end
  ;


  class function TZonePTOutputSet.createZonePTOutputDictionary(): TQOrderedStringStringDictionary;
    begin
      result := createOutputDictionary( firstZonePTIterationOutput(), lastZonePTIterationOutput() );
    end
  ;


  procedure TZonePTOutputSet.debug();
    var
      it: TQIntegerObjectMapIterator;
      pl: TProductionTypeOutputSet;
    begin
      it := TQIntegerObjectMapIterator.create( self );

      repeat
        if( nil <> it.value() ) then
          begin
            pl := it.value() as TProductionTypeOutputSet;

            dbcout( endl + 'TZonePTOutputSet debug: index ' + intToStr( it.key() ), true );
            pl.debug();
            dbcout( 'Done TZonePTOutputSet debug' + endl, true );

            it.incr();
          end
        ;
      until ( nil = it.value() );

      it.Free();
    end
  ;
//-----------------------------------------------------------------------------



//-----------------------------------------------------------------------------
// TZoneOutputSet
//-----------------------------------------------------------------------------
  constructor TZoneOutputSet.create( db: TSMDatabase );
    var
      res: TSqlResult;
      row: TSqlRow;
      query: string;

      zoneID: integer;
      
      olSet: TIterationOutputSet;

      it: TQIntegerObjectMapIterator;
      ol: TIterationOutputSet;
      k: TIterationOutputType;
    begin
      inherited create();

      _startType := firstZoneIterationOutput();
      _endType := lastZoneIterationOutput();

      query := 'SELECT `zoneID` FROM `inZone`';

      res := TSqlResult.create( query, ( db as TSqlDatabase ) );

      row := res.fetchArrayFirst();
      while( nil <> row ) do
        begin
          // For each zone ID, create an instance of TIterationOutputSet
          // and add it to this map.
          zoneID := row.field('zoneID');

          olSet := TIterationOutputSet.create( db, StatsZones, -1, zoneID );
          self.Add( zoneID, olSet );

          row := res.fetchArrayNext();
        end
      ;

      res.Free();

      // "Zone 0" is a special case that's filled with N/As
      olSet := TIterationOutputSet.create( db, StatsZones );

      it := TQIntegerObjectMapIterator.create( self );

      if( nil <> it.value() ) then
        begin
          repeat
            ol := (it.value() as TIterationOutputSet);

            for k := _startType to _endType do
              begin
                olSet.resultSet( k ).values.resize( ol.resultSet( k ).values.count );

                if( k in [ ZZonesOccurred ] ) then
                  olSet.resultSet( k ).values.fill( ol.resultSet( ZMaxZoneArea ).dataCount )
                else
                  olSet.resultSet( k ).values.Fill( UNSET )
                ;
              end
            ;
            it.incr();
          until ( nil = it.value() );

        end
      ;

      it.Free();

      self.Add( 0, olSet );
    end
  ;


  destructor TZoneOutputSet.destroy();
    begin
      self.deleteValues();
      inherited destroy();
    end
  ;


  function TZoneOutputSet.item( const zoneID: integer ): TIterationOutputSet;
    begin
      result := value( zoneID ) as TIterationOutputSet;
    end
  ;

  
  function TZoneOutputSet.resultSet( const outputVariable: TIterationOutputType; const zoneID: integer ): TIterationOutputArray;
    begin
      result := self.item( zoneID ).resultSet( outputVariable );
    end
  ;


  class function TZoneOutputSet.zoneOutputCount(): integer;
    var
      i: integer;
    begin
      result := 0;
      for i := integer( firstZoneIterationOutput() ) to integer( lastZoneIterationOutput() ) do
        inc( result )
      ;
    end
  ;


  class function TZoneOutputSet.createZoneOutputDictionary(): TQOrderedStringStringDictionary;
    begin
      result := createOutputDictionary( firstZoneIterationOutput(), lastZoneIterationOutput() );
    end
  ;


  procedure TZoneOutputSet.debug();
    var
      it: TQIntegerObjectMapIterator;
      ol: TIterationOutputSet;
    begin
      it := TQIntegerObjectMapIterator.create( self );

      repeat
        if( nil <> it.value() ) then
          begin
            ol := it.value() as TIterationOutputSet;

            dbcout( endl + 'TZoneOutputSet debug: index ' + intToStr( it.key() ), true );
            ol.debug();
            dbcout( 'Done TZoneOutputSet debug' + endl, true );

            it.incr();
          end
        ;
      until ( nil = it.value() );

      it.Free();
    end
  ;
//-----------------------------------------------------------------------------




//-----------------------------------------------------------------------------
// TScenarioOutputSet
//-----------------------------------------------------------------------------
  constructor TScenarioOutputSet.create( db: TSMDatabase; const costsUsed, zonesUsed, zoneCostsUsed: boolean );
    begin
      inherited create();

      _zonePTStats := nil;
      _costStats := nil;
      _epiStats := nil;
      _zoneStats := nil;

      if( zonesUsed ) then
        begin
          _zonePTStats := TZonePTOutputSet.create( db, zoneCostsUsed );
          _zoneStats := TZoneOutputSet.create( db );
        end
      ;

      if( costsUsed ) then
        _costStats := TProductionTypeOutputSet.create( db, StatsCosts )
      ;

      _epiStats := TProductionTypeOutputSet.create( db, StatsEpi );
      //_epiStats.debug();
    end
  ;


  destructor TScenarioOutputSet.destroy();
    begin
      if( nil <> _zonePTStats ) then
        _zonePTStats.Free()
      ;
      if( nil <> _zoneStats ) then
        _zoneStats.Free()
      ;
      if( nil <> _costStats ) then
        _costStats.Free()
      ;

      _epiStats.free();

      inherited destroy();
    end
  ;
//-----------------------------------------------------------------------------

end.
